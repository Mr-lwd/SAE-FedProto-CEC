\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{algorithm}  % For pseudo-code
\usepackage{algpseudocode} % For more flexible pseudo-code formatting
\usepackage{amsmath} % For advanced math formatting
\usepackage{booktabs} % For professional-quality tables

\title{Algorithms}
\author{1850245174 }
\date{December 2024}

\begin{document}

\maketitle

\section{Introduction}

This paper introduces various algorithms used in our research.

\section{Asynchronous Baseline Algorithm}

Below is a table of symbols used in the algorithms:

\begin{table}[H]
    \centering
    \begin{tabular}{@{}lp{10cm}@{}}
        \toprule
        \textbf{Symbol}                       & \textbf{Description}                                                                                                                  \\
        \midrule
        \( J \)                               & Number of classes                                                                                                                     \\
        \( T \)                               & Global rounds                                                                                                                         \\
        \( E \)                               & Edge rounds                                                                                                                           \\
        \( K \)                               & Local epochs                                                                                                                          \\
        \( L \)                               & Number of edge servers                                                                                                                \\
        \( B \)                               & The buffer of the cloud server with a static length                                                                                   \\
        \( N^l \)                             & Number of clients in the $l$-th each edge server                                                                                      \\
        \( D_{i,j} \)                         & A subset of the local dataset \(D_i\) of the $i$-th client, containing training instances of class $j$.                                        \\
        \( \mathcal{N}_j^l  \)                & Number of clients in edge $l$ containing class $j$ that have participated in aggregation                                              \\
        \( {\mathcal{N}_j^{l,\text{old}}}  \) & Last number of clients in edge $l$ containing class $j$ that have participated in aggregation                                         \\
        % \( \mathcal{N}_j  \)           & Number of edge servers $l$ containing class $j$ that have participated in aggregation                            \\
        % \( {\mathcal{N}_j}^{'}  \)           & Last number of edge servers $l$ containing class $j$ that have participated in aggregation                            \\

        % \( S^l \)        & Set of clients in the \( l \)-th edge server  \\ 
        \( S^{l} \)                           & Set of clients participating in training in the \( l \)-th edge server                                                                \\
        \( \bar{C}_j \)                       & Aggregated prototype of class $j$ in the cloud edge server                                                                            \\
        \( C^l_j \)                           & Aggregated prototype of class $j$ from the \( l \)-th edge server                                                                     \\
        \( C^{l,\text{old}}_j \)              & Last version of aggregated prototype of class $j$ from the \( l \)-th edge server stored in the cloud server                          \\
        \( c^l_{i, j} \)                      & Aggregated prototype of class $j$ from the client \(i\) in  the \( l \)-th edge server                                                \\
        \( c_{i, j}^{l, \text{old}} \)        & Last version of the aggregated prototype of class \( j \) from client \( i \) in the \( l \)-th edge server stored in the edge server \\
        \bottomrule
    \end{tabular}
    \caption{Symbol Table}
\end{table}

The following algorithm demonstrates how to calculate the factorial of a number.

\begin{algorithm}[H]
    \caption{Hierarchical Federated Prototype Learning -Part 1}
    \begin{algorithmic}[1]
        % \State \textbf{Input: nothing}
        % \State \textbf{Output: nothing}

        \Procedure{cloud server executes}{}
        \State Initialize global prototype set \( \bar{C}\) for all classes and weights for clients with heterogeneous models
        \State All edge servers choose a set of clients $S^l$ and execute in parallel
        \For{$t = 1, \dots, T$}
        \State Clear the buffer \(B\)

        \While{The buffer is not full}
        \State Receive a pair \( (C^l, \mathcal{N}^l) \) from one edge server
        \State Fill the buffer \(B\) with \( C^l \)
        \EndWhile
        \State \( \bar{C} \gets \text{CloudUpdate}(B) \)
        \State Send \( \bar{C} \) to edge servers participating in the current global aggregation
        \State These edge servers rechoose $S^l$ and re-execute
        \EndFor
        \EndProcedure

        \Procedure{edge server executes}{}
        \State Receive \( \bar{C} \) from the cloud server
        \For{$e = 1, \dots, E$} \Comment{Edge rounds, E is static 1}
        \State Send \( \bar{C} \) to client \( i \in S^{l} \)
        \For{each client \( i \) in parallel}
        \State \( c^l_i \gets \text{ClientUpdate}(i, \bar{C_i}) \)
        \EndFor
        \State \( C^l \gets \text{EdgeAggregate}(\{ c^l_i \}_{i \in S^{l}}) \)
        \State \( \bar{C} \gets \text{EdgeUpdate}(\bar{C}, C^l) \) \Comment{Must know client distribution of all edges, not implement now}
        \EndFor
        \State Send a pair \( (C^l, \mathcal{N}^l) \) to the cloud server
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

% \newpage  % 强制换页

\begin{algorithm}[H]
    \caption{Hierarchical Federated Prototype Learning -Part 2}
    \begin{algorithmic}[1]
        \Procedure{CloudUpdate}{buffer}
        \For{$j = 1, \dots, J$}
        \State \( \hat{C}_{j} \gets \sum_{l=1}^{L} {\mathcal{N}_j^{l,\text{old}}} \cdot\bar{C}_{j} \) \Comment{Extend the aggregated prototypes $\bar{C}$}

        \For{$(C^l, \mathcal{N}^l) \in \text{buffer}$}
        \State \( \hat{C}_{j}  \gets \hat{C}_{j} + {\mathcal{N}_j^l} \cdot C^l_j \)
        \If{$C^{l,\text{old}}_{j}$ is not empty}
        \State \( \hat{C}_{j}  \gets \hat{C}_{j} - {\mathcal{N}_j^{l,\text{old}}} \cdot C_j^{l, \text{old}} \)
        % \State \( \mathcal{N}_j \gets \mathcal{N}_j + 1 \)
        \EndIf
        \State \( {\mathcal{N}_j^{l,\text{old}}} \gets \mathcal{N}_j^l \)
        \EndFor
        \State \( \bar{C}_{j} \gets \frac{\hat{C}_{j}}{\sum_{l=1}^{L} {\mathcal{N}_j^{l,\text{old}}}} \)
        \EndFor
        \State \( C^{l,\text{old}} \gets C^l \) for \( l \in B \)
        % \State \( C^{l,old} \text{ remains unchanged for } l \notin B \)
        \State \Return \( \bar{C} \)
        \EndProcedure

        \Procedure{EdgeAggregate}{$l, \{ c^l_i \}_{i \in S^{l}}$}
        \For{$j = 1, \dots, J$}
        \State \( {\hat{C^l_j}} \gets \mathcal{N}^l_j \cdot C^l_{j} \)
        \For{each $c^l_i$}

        \State \( {\hat{C^l_j}}  \gets {\hat{C^l_j}} + c^l_{i,j} \)
        \If{$c^{l,\text{old}}_{i,j}$ is not empty}
        \State \( {\hat{C^l_j}}  \gets {\hat{C^l_j}} - c^{l,\text{old}}_{i,j}\)
        \Else
        \State \( \mathcal{N}_j^l \gets \mathcal{N}_j^l + 1 \)
        \EndIf
        \EndFor
        \State \( {C^l_j} \gets \frac{{\hat{C^l_j}}}{\mathcal\mathcal{N}_j^l} \)
        \EndFor
        \State \( c^{l,\text{old}}_i \gets c^l_i \) for \( i \in S^l \)
        % \State \( c^{l,old}_i \text{ remains unchanged for } i \notin S^l\)
        \State \Return \( C^l \)
        \EndProcedure

        \Procedure{ClientUpdate}{$i, \bar{C_i}$}
        \For{$k=1, \dots, K$}
        \For{batch (\(x,y\)) $\in$ \(D_i\)}
        \State Compute client prototypes by Eq.?.
        \State Compute loss by Eq.? using client prototypes.
        \State Update client model according to the loss.
        \EndFor
        \EndFor
        \State \Return \( c^l_i \)
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\section{Proposed Algorithm}

\end{document}
